"""Module for Ptp and Density classes."""

import sys
# Can't raise rlimit from within sphinx
if "sphinx" not in sys.modules:
    import resource as rs
    rs.setrlimit(rs.RLIMIT_STACK, (rs.RLIM_INFINITY, rs.RLIM_INFINITY))
import os
os.environ["OMP_NUM_THREADS"] = "1"
import copy
from typing import Callable
import numpy as np
from firedrake import *
from firedrake.__future__ import interpolate


class Density(object):
    """
    Density class containing the cdf, qdf and pdf of a function Y(X).
    
    Instances of this class are returned by the Ptp class when the
    fit method is called on a function Y(X) to return

    F(y), Q(p), f(φ)

    the "CDF", "QDF" & "PDF" over their corresponding probability space Ω_Y.
    This class allows these functions to be easily composed and plotted.

    Examples
    --------
    Compose the QDF and CDF::

        >>> density.compose(density.qdf, density.cdf, quadrature_degree=100)
    
    Plot the CDF and PDF::
        
        >>> density.plot('CDF')
        >>> density.plot('PDF')

    """

    def __init__(self, ptp, y, cdf, qdf, pdf):
        """
        Initialise the Density object.
        
        Parameters
        ----------
        ptp : Ptp
            Ptp object corresponding to Y(X).
        y,cdf,qdf,pdf : firedrake Function
            Firedrake functions generated by Ptp corresponding to Y(X).
        """
        self.ptp = ptp
        self.y = y
        self.cdf = cdf
        self.qdf = qdf
        self.pdf = pdf

        return None

    def compose(self, f, g, quadrature_degree):
        """
        Return the projection of the function composition 
        f o g(y) = f(g(y)) 
        into the space of test functions.

        Parameters
        ----------
        f,g : firedrake Function
            Input functions to compose.

        Returns
        -------
        f(g(y)) : firedrake Function
            Composition projected into the space DG1
        """
        mesh_g = g.function_space().mesh()
        mesh_f = f.function_space().mesh()

        self.V_fgE = FiniteElement(family="Quadrature", cell="interval", degree=quadrature_degree, quad_scheme='default')
        self.V_fg = FunctionSpace(mesh=mesh_g, family=self.V_fgE)
        fg = Function(self.V_fg)

        m = self.V_fg.mesh()
        w = VectorFunctionSpace(m, self.V_fg.ufl_element())
        y_vec = assemble(interpolate(m.coordinates, w))

        y_q = [[y_i,] for y_i in y_vec.dat.data[:]]
        vom = VertexOnlyMesh(mesh_g, y_q)
        P0DG = FunctionSpace(vom, "DG", 0)
        g_vec = assemble(interpolate(g, P0DG))

        g_q = [[g_i,] for g_i in g_vec.dat.data[:]]
        vom = VertexOnlyMesh(mesh_f, g_q)
        P0DG = FunctionSpace(vom, "DG", 0)
        f_vec = assemble(interpolate(f, P0DG))

        fg.dat.data[:] = f_vec.dat.data[:]

        # Grab the mesh of the function composition
        mesh_fg = fg.function_space().mesh()
        
        # Define the space of test functions
        V_test = FunctionSpace(mesh=mesh_fg, family='DG', degree=1)

        # Create Trial and Test functions
        u = TrialFunction(V_test)
        v = TestFunction(V_test)

        # Define the bilinear and linear forms
        a = inner(u, v)*dx
        L = inner(fg, v)*dx(degree=quadrature_degree)

        # Solve
        fg_test = Function(V_test)
        solve(a == L, fg_test)
        
        return fg_test

    def plot(self, function='CDF'):
        """
        Visualise the CDF, QDF and PDF using inbuilt plotting routines.
        
        Parameters
        ----------
        function : string
            The function to plot e.g. 'CDF, 'PDF', 'QDF'
        """
        import matplotlib.pyplot as plt
        from firedrake.pyplot import plot

        if function == 'CDF':
            try:
                plot(self.cdf, num_sample_points=50)
                plt.title(r'CDF', fontsize=20)
                plt.ylabel(r'$F_Y$', fontsize=20)
                plt.xlabel(r'$y$', fontsize=20)
                plt.tight_layout()
                plt.grid()
                plt.show()
            except Exception as e:
                warning("Cannot plot figure. Error msg: '%s'" % e)
        elif function == 'QDF':

            try:
                plot(self.qdf, num_sample_points=50)
                plt.title(r'QDF', fontsize=20)
                plt.ylabel(r'$Q_Y$', fontsize=20)
                plt.xlabel(r'$p$', fontsize=20)
                plt.tight_layout()
                plt.grid()
                plt.show()
            except Exception as e:
                warning("Cannot plot figure. Error msg: '%s'" % e)
        elif function == 'PDF':

            try:
                # Plot within the elements
                plot(self.pdf["fc"], num_sample_points=50)
                
                # Plot the Dirac measures
                m_y = self.pdf["fs"].function_space().mesh()
                loc = m_y.coordinates.dat.data[:]
                jump = self.pdf["fs"].dat.data[:]

                y = np.linspace(0, 1, 50)
                for j_i, y_i in zip(jump, loc):
                    plt.plot(y_i*np.ones(50), j_i*y, 'b--')
                    if abs(j_i) > 1e-03:
                        plt.plot(y_i, j_i, 'ro')
                
                plt.title(r'PDF', fontsize=20)
                plt.ylabel(r'$f_Y$', fontsize=20)
                plt.xlabel(r'$y$', fontsize=20)
                plt.tight_layout()
                plt.grid()
                plt.show()
            except Exception as e:
                warning("Cannot plot figure. Error msg: '%s'" % e)
        return None

    def evaluate(self, y):
        """
        Return the CDF, QDF and PDF at the point(s) y.
        
        Parameters
        ----------
        y : array-like
            A grid to evaluate on.

        Returns
        -------
        cdf_at_y,qdf_at_y,pdf_at_y : array-like
            cdf,qdf,pdf evaluated on y.
        """
        
        cdf_at_y = np.asarray(self.cdf.at(y))
        qdf_at_y = np.asarray(self.qdf.at(y))
        pdf_at_y = np.asarray(self.pdf["fc"].at(y))

        return cdf_at_y, qdf_at_y, pdf_at_y

    def __call__(self, g):
        """
        Given a test function g(y) evaluate
            
            int g(y) dF(y)
        
        in terms of its
                
            int g(y) dF(y) := <g,f_c> + <g,f_s> 
        
        where f_c & f_s are the Riesz representors of f(φ).

        Parameters
        ----------
        g : Firedrake function or UFL expression
            A valid test function

        Returns
        -------
        integral : float
            The integral int g(y) dF(y)
        """

        fc = self.pdf["fc"]
        fs = self.pdf["fs"]
        return assemble(g*fc*dx) + assemble(avg(g)*fs*dS + g*fs*ds)


class Ptp(object):
    """
    Ptp class - physical to probability.
    
    Given a user provided "function" over a physical "domain"

    Y(X) where X in Ω_X

    this class uses the fit method to return the "CDF", "QDF" & "PDF"

    F(y), Q(p), f(y)

    over their corresponding probability space Ω_Y. The method uses
    a finite element discretisation consisting of n elements "bins".

    Parameters
    ----------
    Omega_X : dictionary
        Physical domain of the function Y(X).
    Omega_Y : dictionary
        Range of the function Y(X).
    n_elements : int
        Number of finite elements.

    Returns
    -------
    density : Density object
        A density object containing the CDF, QDF and PDF of Y(X).
    
    Examples
    --------
    Specify the domain size(s) & number of finite elements/bins::

        >>> ptp = Ptp(Omega_X={'x1': (0, 1)}, Omega_Y={'Y': (0, 1)}, n_elements=5)
        >>> x1 = ptp.x_coords()
    
    Compute the density of a function on this domain::
        
        >>> density = ptp.fit(Y=x1, quadrature_degree=100)
        >>> density.plot('CDF')
  
    """

    def __init__(self, Omega_X={'x1': (-1, 1), 'x2': (-1, 1)}, Omega_Y={'Y': (0, 1)}, n_elements=10):
        """
        Intialise the Ptp object.
        
        Parameters
        ----------
        Omega_X : dictionary
            Physical domain of the function Y(X).
        Omega_Y : dictionary
            Range of the function Y(X).
        n_elements : int
            Number of finite elements.
        """
        # Physical space
        self.Omega_X = Omega_X
        self.Omega_Y = Omega_Y
        self.n_e = n_elements

        # Mesh & Coordinates
        if len(self.Omega_X) == 1:
            self.cell_type = "interval"
            self.cell_type = "interval"
            mesh_x = IntervalMesh(ncells=1, length_or_left=self.Omega_X['x1'][0], right=self.Omega_X['x1'][1])
        elif len(self.Omega_X) == 2:
            self.cell_type = "quadrilateral"
            self.cell_type = "quadrilateral"
            mesh_x = RectangleMesh(nx=1, ny=1, Lx=self.Omega_X['x1'][1], Ly=self.Omega_X['x2'][1], originX=self.Omega_X['x1'][0], originY=self.Omega_X['x2'][0], quadrilateral=True)
        else:
            raise ValueError('The domain Ω must be 1D or 2D \n')

        self.m_y = IntervalMesh(ncells=self.n_e, length_or_left=self.Omega_Y['Y'][0], right=self.Omega_Y['Y'][1])
        self.m_yx = ExtrudedMesh(mesh_x, layers=self.n_e, layer_height=1./self.n_e, extrusion_type='uniform')

        # Finite-Element
        self.R_FE = FiniteElement(family="DG", cell=self.cell_type, degree=0, variant="equispaced")
        self.R_FE = FiniteElement(family="DG", cell=self.cell_type, degree=0, variant="equispaced")
        self.V_FE = FiniteElement(family="DG", cell="interval", degree=1, variant="equispaced")
        self.V_QE = FiniteElement(family="CG", cell="interval", degree=1, variant="equispaced")
        self.V_fc = FiniteElement(family="DG", cell="interval", degree=0, variant="equispaced")
        self.V_fs = FiniteElement(family="CG", cell="interval", degree=1, variant="equispaced")

        # Function-space
        self.V_F = FunctionSpace(mesh=self.m_y, family=self.V_FE)
        T_element = TensorProductElement(self.R_FE, self.V_FE)
        self.V_F_hat = FunctionSpace(mesh=self.m_yx, family=T_element)
        self.V_fc = FunctionSpace(mesh=self.m_y, family=self.V_fc)
        self.V_fs = FunctionSpace(mesh=self.m_y, family=self.V_fs)

    def y_coord(self):
        """Return the y coordinate on the interval mesh."""
        return SpatialCoordinate(self.m_y)[0]

    def xy_coords(self):
        """Return the X & Y co-ordinates of the extended mesh."""
        return SpatialCoordinate(self.m_yx)

    def x_coords(self):
        """Return the co-ordinates of X=(x1,x2)."""
        if len(self.Omega_X) == 1:
            x1, _ = self.xy_coords()
            return x1
        elif len(self.Omega_X) == 2:
            x1, x2, _ = self.xy_coords()
            return x1, x2

    def map(self, Y):
        """
        Map Y(x) so that its range becomes the unit interval [0,1].
        
        Parameters
        ----------
        Y : UFL expression
            A UFL expression Y(X) terms of x_coords() with range Ω_Y.
        
        Returns
        -------
        Y_mapped : UFL expression
            A UFL expression in terms of x_coords() with range [0,1].
        """
        return Y/(self.Omega_Y['Y'][1]-self.Omega_Y['Y'][0]) - self.Omega_Y['Y'][0]/(self.Omega_Y['Y'][1]-self.Omega_Y['Y'][0])

    def indicator(self, Y):
        """
        Apply the indicator function I(y,X) to the random function Y(X).
        
        Parameters
        ----------
        Y : UFL expression
            A UFL expression Y(X) terms of x_coords() with range [0,1].
        
        Returns
        -------
        I(y,X) : UFL expression
            A conditional operator implementing the indicator function.
        """
        if len(self.Omega_X) == 1:
            _, y = self.xy_coords()
        elif len(self.Omega_X) == 2:
            _, _, y = self.xy_coords()
        return conditional(Y < y, 1, 0)

    def _cdf(self, Y, quadrature_degree):
        """
        Return the cdf F(y) of the random function Y(X).
        
        Parameters
        ----------
        Y : UFL expression
            A UFL expression Y(X) terms of x_coords() with range [0,1].
        quadrature_degree : int
            Quadrature degree used to evaluate the projection of I(y,X).
        
        Returns
        -------
        F : firedrake Function
            The cdf F(y) of the random function Y(X).
        """
        # Define trial & test functions on V_F_hat
        u = TrialFunction(self.V_F_hat)
        v = TestFunction(self.V_F_hat)

        # Construct the linear & bilinear forms
        a = inner(u, v) * dx
        L = inner(self.indicator(Y), v) * dx(degree=quadrature_degree, scheme="default", domain=self.m_yx)

        # Solve for F_hat
        F_hat = Function(self.V_F_hat)
        solve(a == L, F_hat)
        # Recover F_Y(y) in V_F
        F = Function(self.V_F)

        # Sort a linear function in ascending order
        # this creates a DOF map which matches
        # the extended mesh which are in ascending order
        y = self.y_coord()
        ys = assemble(interpolate(y, self.V_F))
        indx = np.argsort(ys.dat.data)

        # Pass F_hat into F
        F.dat.data[indx] = F_hat.dat.data[:]

        # If the CDF is constant i.e F(y) = const do nothing otherwise
        # apply the boundary conditions by extending the endpoints to 0,1
        if np.allclose(F.dat.data[:], F.dat.data[0]) is False:
            F.dat.data[0] = 0  # left end point
            F.dat.data[-1] = 1  # right end point

        # Apply a slope limiter to F
        F = self.slope_limiter(F)

        # Re-enforce
        if np.allclose(F.dat.data[:], F.dat.data[0]) is False:
            F.dat.data[0] = 0  # left end point
            F.dat.data[-1] = 1  # right end point

        return F

    def _qdf(self, F):
        """
        Return the QDF Q_Y(p) of Y(x) by inverting F(y) = p.
        
        Parameters
        ----------
        F : firedrake Function
            The cdf F(y) of the random function Y(X).
        
        Returns
        -------
        Q : firedrake Function
            The qdf Q(p) of the random function Y(X).
        """
        # (1) Construct the non-uniform domain Ω_p
        # Obtain dofs F_i = F(z_i) from the CDF
        F_i = F.dat.data[:]

        # We extend Ω_p to include the endpoints 0,1
        # As F(y=0) ≠ 0 & F(y=1) ≠ 1 due to numerical error
        p = np.hstack(([0], F_i, [1]))

        # Make a 1D mesh whose vertices are given by the p values
        layers = len(p[1:] - p[:-1])
        m_p = UnitIntervalMesh(ncells=layers)
        m_p.coordinates.dat.data[:] = p[:]

        # (2) Create a function Q(p) on this mesh
        V_Q = FunctionSpace(mesh=m_p, family=self.V_QE)
        Q = Function(V_Q)

        # (3) Extract the mesh coordinates of the CDF
        m_y = self.V_F.mesh()
        w = VectorFunctionSpace(m_y, self.V_F.ufl_element())
        y_m = assemble(interpolate(m_y.coordinates, w)).dat.data

        # Append the coordinates of the boundaries
        y_l = m_y.coordinates.dat.data[0]  # left endpoint
        y_r = m_y.coordinates.dat.data[-1]  # right endpoint
        y_i = np.hstack(([y_l], y_m, [y_r]))

        # Assign Q(F_i) = y_i
        Q.dat.data[:] = y_i[:]

        return Q

    def _pdf(self, F):
        """
        Return the PDF f(φ) of Y(x) in terms of its Riesz representor
        within each element fc(y) and at the element facets fs(y).
        
        Parameters
        ----------
        F : firedrake Function
            The cdf F(y) of the random function Y(X).
        
        Returns
        -------
        f : dict of firedrake Functions
            The distribution f(φ) of the random function Y(X) as a distribution
            in terms of fs(y) within the elements and fs(y) at element facets.
        """
        
        # Define trial & test functions on V_fc
        u = TrialFunction(self.V_fc)
        v = TestFunction(self.V_fc)

        # Construct the linear & bilinear forms
        a = inner(u, v)*dx
        L = inner(F.dx(0), v)*dx
        
        # Solve for fc
        fc = Function(self.V_fc)
        solve(a == L, fc)

        # Define trial & test functions on V_dirac
        u = TrialFunction(self.V_fs)
        v = TestFunction(self.V_fs)

        # Define the variational form
        a = inner(avg(u), avg(v))*dS + inner(u, v)*ds  # avg(v) = (v(+) + v(-))/2
        L_internal = -(F('+')*v('+') - F('-')*v('-')) * dS
        L_external = -((F-1)*v*ds(2) - (F-0)*v*ds(1))  # The jump at the end-points 
        L = L_internal + L_external
       
        # Solve for fs
        fs = Function(self.V_fs)
        solve(a == L, fs)

        return {"fc": fc, "fs": fs}

    def _external_function(self, Y_numerical, quadrature_degree):
        """
        Return Y_numerical(x_q) at the quadrature points x_q,specified by the quadrature degree.

        Parameters
        ----------
        Y_numerical: callable
            Numerical representation of the function Y(x)
        quadrature_degree: int
            Order of the quadrature scheme to use.

        Returns
        -------
        Y : firedrake Function
            Y_numerical evaluated at points x_q of a quadrature mesh.
        """
        V_XE = FiniteElement(family="Quadrature", cell=self.cell_type, degree=quadrature_degree, quad_scheme="default")
        V_YE = FiniteElement(family="DG", cell="interval", degree=0, variant="equispaced")
        T_element = TensorProductElement(V_XE, V_YE)
        V_Y = FunctionSpace(mesh=self.m_yx, family=T_element)
        Y = Function(V_Y)

        m = V_Y.mesh()
        W = VectorFunctionSpace(m, V_Y.ufl_element())
        x_vec = assemble(interpolate(m.coordinates, W))
        x_q = x_vec.dat.data[:, :-1]
        Y.dat.data[:] = Y_numerical(x_q)

        return Y

    def slope_limiter(self, F):
        """
        Apply a slope limiter to ensure a non-decreasing cdf F(y).
        
        Parameters
        ----------
        F : firedrake Function
            The cdf F(y) of the random function Y(X).
        
        Returns
        -------
        F : firedrake Function
            The slope limited cdf F(y) of the random function Y(X).
        """
        def jump_condition(a_n_minus, a_n_plus, a_0_minus):
            if a_n_plus < a_n_minus:
                return a_n_plus-a_n_minus
            else:
                return min(a_n_plus, a_0_minus) - a_n_minus

        def jumps(F, F_0):

            celldata_0 = F_0.dat.data[:].reshape((-1, 2))

            celldata_n = F.dat.data[:].reshape((-1, 2))
            ne = celldata_n.shape[0]
            jumps = np.zeros(ne)

            # Go through the cells from left to right
            for e in range(ne):

                # (1) cell data
                # e - 1
                if e == 0:
                    cell_n_em1 = np.zeros(2)
                    cell_0_em1 = np.zeros(2)
                else:
                    cell_n_em1 = celldata_n[e-1, :]
                    cell_0_em1 = celldata_0[e-1, :]
                # e
                cell_n_e = celldata_n[e, :]
                cell_0_e = celldata_0[e, :]

                # e + 1
                if e == ne-1:
                    cell_n_ep1 = np.ones(2)
                else:
                    cell_n_ep1 = celldata_n[e+1, :]
                # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                # (2) jumps
                left = jump_condition(cell_n_em1[1], cell_n_e[0], cell_0_em1[1])
                right = jump_condition(cell_n_e[1], cell_n_ep1[0], cell_0_e[1])
                jumps[e] = min(left, right)
                # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            return jumps

        F_0 = copy.deepcopy(F)
        ne = F_0.dat.data[:].reshape((-1, 2)).shape[0]

        # A) Relaxation loop
        error = 1
        iter = 0
        slope = -1
        jo = np.zeros(ne)
        alpha = 0.1
        while (error > 0.01 or slope < 0) and (iter < 10**3):

            # (1) Update dats
            jn = jumps(F, F_0)
            F.dat.data[:].reshape((-1, 2))[:, 0] -= alpha*jn
            F.dat.data[:].reshape((-1, 2))[:, 1] += alpha*jn

            # (2) Error
            iter += 1
            if np.linalg.norm(jn) == 0:
                error = 0.
            else:
                error = np.linalg.norm(jn - jo, 2)/np.linalg.norm(jn, 2)
            jo = jn

            # (3) Calculate the slope
            slopes = F.dat.data[:].reshape((-1, 2))[:, 1] - F.dat.data[:].reshape((-1, 2))[:, 0]
            slope = np.min(slopes)
            if abs(slope) < 1e-12:
                slope = 0.

            # if iter % 100 == 0:
            #     print('Iteration i=%d' % iter, ' error = ', error, 'slope =', slope, '\n')
            #     import matplotlib.pyplot as plt
            #     from firedrake.pyplot import plot
            #     plot(F,num_sample_points=50)
            #     plt.grid()
            #     plt.show()

        # B) Remove remaining illegal discontinuities
        jn = jumps(F, F_0)
        F.dat.data[:].reshape((-1, 2))[:, 0] -= jn
        F.dat.data[:].reshape((-1, 2))[:, 1] += jn

        # C) Check no negative slopes persist
        slopes = F.dat.data[:].reshape((-1, 2))[:, 1] - F.dat.data[:].reshape((-1, 2))[:, 0]
        slope = np.min(slopes)
        if abs(slope) < 1e-12:
            slope = 0.

        if slope < 0:
            #warning('Negative slopes could not be removed: min(slope) = %e \n' % slope)
            from firedrake.slope_limiter import vertex_based_limiter
            Limiter = vertex_based_limiter.VertexBasedLimiter(space=self.V_F)
            Limiter.apply(field=F)
            
        return F

    def fit(self, Y, quadrature_degree=100):
        """
        Return the Density object correspoding to Y(X).
        
        Parameters
        ----------
        Y : UFL expression/callable
            A UFL expression Y(X) terms of x_coords() with range Ω_Y or
            a callable that returns Y(X_i) at the points {X_i} with range Ω_Y. 
        Y : UFL expression/callable
            A UFL expression Y(X) terms of x_coords() with range Ω_Y or
            a callable that returns Y(X_i) at the points {X_i} with range Ω_Y. 
        quadrature_degree : int
            Quadrature degree used to evaluate the projection of I(y,X).
        
        Returns
        -------
        density : class 'Density'
            A Density object containing the CDF, QDF & PDF of Y(X).
        """
               
        if hasattr(Y, 'dx'):
            Y_input = Y
        elif isinstance(Y, Callable):
            Y_input = self._external_function(Y, quadrature_degree)
        else:
            raise ValueError('Expected a UFL expression or python callable \
                             recieved ', type(Y), '\n')
        y = self.y_coord()
        F = self._cdf(self.map(Y_input), quadrature_degree)
        Q = self._qdf(F)
        f = self._pdf(F)
        return Density(self, y, F, Q, f)
